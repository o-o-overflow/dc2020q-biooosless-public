#define GET_LOW_R(var)            (var)
#define SET_LOW_R(var, val)       do { (var) = (val); } while (0)
#define MAKE_FLATPTR_R(seg,off) ((void*)(((u32r)(seg)<<4)+(u32r)(off)))

typedef unsigned char u8r;
typedef unsigned short u16r;
typedef unsigned int u32r;
typedef unsigned long long u64r;


// source code stolen from seabios


// global vars from bda
struct mybda_t {
  u8r disk_interrupt_flag_r;
  u8r floppy_recalibration_status_r;
  u8r floppy_media_state_r[4];
  u8r floppy_track_r[2];
  u8r floppy_last_data_rate_r;
  u8r floppy_return_status_r[7];
  u8r floppy_motor_counter_r;
  u8r FloppyDOR_r;
};

// Definition for common 16bit segment/offset pointers.
struct segoff_s_r {
    union {
        struct {
            u16r offset;
            u16r seg;
        };
        u32r segoff;
    };
};

#define UREG_R(ER, R, RH, RL) union { u32r ER; struct { u16r R; u16r R ## _hi; }; struct { u8r RL; u8r RH; u8r R ## _hilo; u8r R ## _hihi; }; }

// Layout of registers passed in to irq handlers.  Note that this
// layout corresponds to code in romlayout.S - don't change it here
// without also updating the assembler code.
// struct bregs_r {
    // u16r ds;
    // u16r es;
    // UREG_R(edi, di, di8u, di8l);
    // UREG_R(esi, si, si8u, si8l);
    // UREG_R(ebp, bp, bp8u, bp8l);
    // UREG_R(ebx, bx, bh, bl);
    // UREG_R(edx, dx, dh, dl);
    // UREG_R(ecx, cx, ch, cl);
    // UREG_R(eax, ax, ah, al);
    // struct segoff_s_r code;
    // u16r flags;
// } PACKED;

static inline void outb_r(u8r value, u16r port) {
    __asm__ __volatile__("outb %b0, %w1" : : "a"(value), "Nd"(port));
}
static inline u8r inb_r(u16r port) {
    u8r value;
    __asm__ __volatile__("inb %w1, %b0" : "=a"(value) : "Nd"(port));
    return value;
}

#define FRS_IRQ (1<<7)

#define DISK_RET_SUCCESS       0x00
#define DISK_RET_EPARAM        0x01
#define DISK_RET_EADDRNOTFOUND 0x02
#define DISK_RET_EWRITEPROTECT 0x03
#define DISK_RET_ECHANGED      0x06
#define DISK_RET_EBOUNDARY     0x09
#define DISK_RET_EBADTRACK     0x0c
#define DISK_RET_ECONTROLLER   0x20
#define DISK_RET_ETIMEOUT      0x80
#define DISK_RET_ENOTLOCKED    0xb0
#define DISK_RET_ELOCKED       0xb1
#define DISK_RET_ENOTREMOVABLE 0xb2
#define DISK_RET_ETOOMANYLOCKS 0xb4
#define DISK_RET_EMEDIA        0xC0
#define DISK_RET_ENOTREADY     0xAA

#define PORT_FD_BASE           0x03f0
#define PORT_FD_DOR            0x03f2
#define PORT_FD_STATUS         0x03f4
#define PORT_FD_DATA           0x03f5
#define PORT_FD_DIR            0x03f7

#define FLOPPY_SIZE_CODE 0x02 // 512 byte sectors
#define FLOPPY_DATALEN 0xff   // Not used - because size code is 0x02
#define FLOPPY_MOTOR_TICKS 37 // ~2 seconds
#define FLOPPY_FILLBYTE 0xf6
#define FLOPPY_GAPLEN 0x1B
#define FLOPPY_FORMAT_GAPLEN 0x6c
#define FLOPPY_PIO_TIMEOUT 1000
#define FLOPPY_IRQ_TIMEOUT 5000
#define FLOPPY_SPECIFY1 0xAF  // step rate 12ms, head unload 240ms
#define FLOPPY_SPECIFY2 0x02  // head load time 4ms, DMA used
#define FLOPPY_STARTUP_TIME 8 // 1 second

#define FLOPPY_DOR_MOTOR_D     0x80 // Set to turn drive 3's motor ON
#define FLOPPY_DOR_MOTOR_C     0x40 // Set to turn drive 2's motor ON
#define FLOPPY_DOR_MOTOR_B     0x20 // Set to turn drive 1's motor ON
#define FLOPPY_DOR_MOTOR_A     0x10 // Set to turn drive 0's motor ON
#define FLOPPY_DOR_MOTOR_MASK  0xf0
#define FLOPPY_DOR_IRQ         0x08 // Set to enable IRQs and DMA
#define FLOPPY_DOR_RESET       0x04 // Clear = enter reset mode, Set = normal operation
#define FLOPPY_DOR_DSEL_MASK   0x03 // "Select" drive number for next access

#define FCF_WAITIRQ 0x10000
#define FC_CHECKIRQ    (0x08 | (0<<8) | (2<<12))
#define FC_SEEK        (0x0f | (2<<8) | (0<<12) | FCF_WAITIRQ)
#define FC_RECALIBRATE (0x07 | (1<<8) | (0<<12) | FCF_WAITIRQ)
#define FC_READID      (0x4a | (1<<8) | (7<<12) | FCF_WAITIRQ)
#define FC_READ        (0xe6 | (8<<8) | (7<<12) | FCF_WAITIRQ)
#define FC_WRITE       (0xc5 | (8<<8) | (7<<12) | FCF_WAITIRQ)
#define FC_FORMAT      (0x4d | (5<<8) | (7<<12) | FCF_WAITIRQ)
#define FC_SPECIFY     (0x03 | (2<<8) | (0<<12))


#define PORT_DMA_ADDR_2        0x0004
#define PORT_DMA_CNT_2         0x0005
#define PORT_DMA1_MASK_REG     0x000a
#define PORT_DMA1_MODE_REG     0x000b
#define PORT_DMA1_CLEAR_FF_REG 0x000c
#define PORT_DMA1_MASTER_CLEAR 0x000d
#define PORT_DMA_PAGE_2        0x0081
#define PORT_DMA2_MASK_REG     0x00d4
#define PORT_DMA2_MODE_REG     0x00d6
#define PORT_DMA2_MASTER_CLEAR 0x00da


int floppy_drive_pio_r(struct mybda_t *mybda, u8r floppyid, int command, u8r *param);
int floppy_drive_readid_r(struct mybda_t *mybda, u8r floppyid, u8r data_rate_r, u8r head);
u8r floppy_dor_read_r(struct mybda_t *mybda);
void floppy_dor_write_r(struct mybda_t *mybda, u8r val);
void floppy_dor_mask_r(struct mybda_t *mybda, u8r off, u8r on);
int floppy_pio_r(struct mybda_t *mybda, int command, u8r *param);
int dma_floppy_r(u32r addr, int count, int isWrite);
int floppy_wait_irq_r(struct mybda_t *mybda);
int floppy_enable_controller_r(struct mybda_t *mybda);
void floppy_disable_controller_r(struct mybda_t *mybda);

void reyammer_read_from_floppy(u8r cyl, u8r head, u8r sector, char* addr);
void reyammer_print_char(u8r x, u8r y, u8r c);
void reyammer_print_str(u8r x, u8r y, char *str);
void reyammer_read_from_floppy_regs(void);

// for tests
void reyammer_exploit(void);


int main() {
    reyammer_exploit();
    return 0;
}


void reyammer_exploit(void) {
    char output[512];
    reyammer_read_from_floppy(0, 1, 17, (char *)&output);
    reyammer_print_str(0, 3, output);
    __asm__(".2byte 0xfeeb"); // infinite loop
}


void reyammer_print_str(u8r x, u8r y, char *str) {
    char *curr = str;
    while (*curr != '\0') {
        u32r base = 0xb8000;
        u32r off = (++x*2) + (y*160);
        char* target = (char *)(base + off);
        *target = *curr;

        curr++;
    }
}


void reyammer_read_from_floppy(u8r cyl, u8r head, u8r sector, char* addr) {
    struct mybda_t mybdao;
    mybdao.disk_interrupt_flag_r = 0;
    mybdao.floppy_recalibration_status_r = 0;
    // mybdao.floppy_media_state_r[4]
    // mybdao.floppy_track_r[2]
    mybdao.floppy_last_data_rate_r = 0;
    // mybdao.floppy_return_status_r[7]
    mybdao.floppy_motor_counter_r = 0;
    mybdao.FloppyDOR_r = 0;

    struct mybda_t *mybda = &mybdao;
    
    u8r ch = cyl; // cyl
    u8r dh = head; // head
    u8r cl = sector; // sector

    u8r param[8];

    mybda->disk_interrupt_flag_r = 0;
    void *buf_fl = (void *) addr;

    if (!(mybda->floppy_recalibration_status_r & (1<<0)) ||
        !((mybda->floppy_media_state_r)[0] & (1<<4))) {

        param[0] = 0;
        floppy_drive_pio_r(mybda, 0, 0x10107, param);

        u8r frs = mybda->floppy_recalibration_status_r;
        mybda->floppy_recalibration_status_r = frs | (1<<0);
        (mybda->floppy_track_r)[0] = 0;

        floppy_drive_readid_r(mybda, 0, 0, 0);
        u8r old_data_rate_r = ((mybda->floppy_media_state_r)[0]) >> 6;
        mybda->floppy_last_data_rate_r = (old_data_rate_r<<2) | (0<<6);
        u8r fms = (0<<6) | (1<<4) | 0x7;
        (mybda->floppy_media_state_r)[0] = fms;

        param[0] = 0xaf;
        param[1] = 0x02;
        floppy_pio_r(mybda, 0x203, param);
    }

    // Seek to cylinder if needed.
    // u8r lastcyl = (mybda->floppy_track_r)[0];
    // if (ch != lastcyl) {
        // param[0] = 0;
        // param[1] = ch;
        // floppy_drive_pio_r(mybda, 0, 0x1020f, param);
        // (mybda->floppy_track_r)[0] = ch;
    // }

    param[0] = (dh << 2) | 0; // HD DR1 DR2
    param[1] = ch;
    param[2] = dh;
    param[3] = cl;
    param[4] = 0x2;
    param[5] = cl + 1 - 1; // last sector to read on track
    param[6] = 0x1B;
    param[7] = 0xff;
  
    dma_floppy_r((u32r)buf_fl, 512, 0);
    floppy_drive_pio_r(mybda, 0, 0x178e6, param);

    // Populate floppy_return_status_r in BDA
    // int i;
    // for (i=0; i<7; i++)
      // (mybda->floppy_return_status_r)[i] = param[i];
}


int floppy_drive_pio_r(struct mybda_t *mybda, u8r floppyid, int command, u8r *param)
{
    // Enable controller if it isn't running.
    // if (!(floppy_dor_read_r(mybda) & FLOPPY_DOR_RESET)) {
    floppy_enable_controller_r(mybda);
    // }

    // set the disk motor timeout value of INT 08 to the highest value
    mybda->floppy_motor_counter_r = 255;

    // Check if the motor is already running
    u8r motor_mask = FLOPPY_DOR_MOTOR_A << floppyid;

    // Turn on motor of selected drive, DMA & int enabled, normal operation
    floppy_dor_write_r(mybda, motor_mask | FLOPPY_DOR_IRQ | FLOPPY_DOR_RESET | floppyid);

    // Send command.
    floppy_pio_r(mybda, command, param);
    mybda->floppy_motor_counter_r = FLOPPY_MOTOR_TICKS; // reset motor timeout

    // Check IRQ command is needed after irq commands with no results
    // if ((command & FCF_WAITIRQ) && ((command >> 12) & 0xf) == 0) {
    return floppy_pio_r(mybda, FC_CHECKIRQ, param);
// }
    // return DISK_RET_SUCCESS;
}


int floppy_enable_controller_r(struct mybda_t *mybda)
{
    // dprintf(2, "Floppy_enable_controller\n");
    // Clear the reset bit (enter reset state), but set 'enable IRQ and DMA'
    floppy_dor_mask_r(mybda, FLOPPY_DOR_RESET, FLOPPY_DOR_IRQ);
    // Real hardware needs a 4 microsecond delay
    // usleep(4);
    // Set the reset bit (normal operation) and keep 'enable IRQ and DMA' on
    floppy_dor_mask_r(mybda, 0, FLOPPY_DOR_IRQ | FLOPPY_DOR_RESET);
    int ret = floppy_wait_irq_r(mybda);
    if (ret)
        return ret;

    // After the interrupt is received, send 4 SENSE INTERRUPT commands to
    // clear the interrupt status for each of the four logical drives,
    // supported by the controller.
    // See section 7.4 - "Drive Polling" of the Intel 82077AA datasheet for
    // a more detailed description of why this voodoo needs to be done.
    // Without this, initialization fails on real controllers (but still works
    // in QEMU)
    u8r param[2];
    int i;
    for (i=0; i<4; i++) {
        ret = floppy_pio_r(mybda, FC_CHECKIRQ, param);
        if (ret)
            return ret;
    }
    return DISK_RET_SUCCESS;
}

u8r
floppy_dor_read_r(struct mybda_t *mybda)
{
    return mybda->FloppyDOR_r;
}

void
floppy_dor_write_r(struct mybda_t *mybda, u8r val)
{
    outb_r(val, PORT_FD_DOR);
    mybda->FloppyDOR_r = val;
}

void
floppy_dor_mask_r(struct mybda_t *mybda, u8r off, u8r on)
{
    floppy_dor_write_r(mybda, (floppy_dor_read_r(mybda) & ~off) | on);
}

// static inline void outb_r(u8r value, u16r port) {
    // __asm__ __volatile__("outb %b0, %w1" : : "a"(value), "Nd"(port));
// }

void
floppy_disable_controller_r(struct mybda_t *mybda)
{
    // dprintf(2, "Floppy_disable_controller\n");
    // Clear the reset bit (enter reset state) and clear 'enable IRQ and DMA'
    floppy_dor_mask_r(mybda, FLOPPY_DOR_IRQ | FLOPPY_DOR_RESET, 0);
}


int
floppy_wait_irq_r(struct mybda_t *mybda)
{
    u8r frs = mybda->floppy_recalibration_status_r;
    mybda->floppy_recalibration_status_r = frs & ~FRS_IRQ;
    // u32r end = timer_calc(FLOPPY_IRQ_TIMEOUT);
    // for (;;) {
        // if (timer_check(end)) {
            // warn_timeout();
            // floppy_disable_controller_r();
            // return DISK_RET_ETIMEOUT;
        // }
        // frs = GET_BDA_R(floppy_recalibration_status_r);
        // if (frs & FRS_IRQ)
            // break;
        // Could use yield_toirq() here, but that causes issues on
        // bochs, so use yield() instead.
        // yield_r();
    // }

    mybda->floppy_recalibration_status_r = frs & ~FRS_IRQ;
    return DISK_RET_SUCCESS;
}

int floppy_pio_r(struct mybda_t *mybda, int command, u8r *param)
{
    // dprintf(9, "Floppy pio command %x\n", command);
    // Send command and parameters to controller.
    // u32r end = timer_calc(FLOPPY_PIO_TIMEOUT);
    int send = (command >> 8) & 0xf;
    int i = 0;
    for (;;) {
        u8r sts = inb_r(PORT_FD_STATUS);
        if (!(sts & 0x80)) {
            // if (timer_check_r(end)) {
                // warn_timeout_r();
                // floppy_disable_controller_r();
                // return DISK_RET_ETIMEOUT;
            // }
            // yield();
            continue;
        }
        if (sts & 0x40) {
            floppy_disable_controller_r(mybda);
            return DISK_RET_ECONTROLLER;
        }
        if (i == 0)
            outb_r(command & 0xff, PORT_FD_DATA);
        else
            outb_r(param[i-1], PORT_FD_DATA);
        if (i++ >= send)
            break;
    }

    // Wait for command to complete.
    if (command & FCF_WAITIRQ) {
        int ret = floppy_wait_irq_r(mybda);
        if (ret)
            return ret;
    }

    // Read response from controller.
    // end = timer_calc_r(FLOPPY_PIO_TIMEOUT);
    int receive = (command >> 12) & 0xf;
    i = 0;
    for (;;) {
        u8r sts = inb_r(PORT_FD_STATUS);
        if (!(sts & 0x80)) {
            // if (timer_check_r(end)) {
                // warn_timeout_r();
                // floppy_disable_controller_r();
                // return DISK_RET_ETIMEOUT;
            // }
            // yield();
            continue;
        }
        if (i >= receive) {
            if (sts & 0x40) {
                floppy_disable_controller_r(mybda);
                return DISK_RET_ECONTROLLER;
            }
            break;
        }
        if (!(sts & 0x40)) {
            floppy_disable_controller_r(mybda);
            return DISK_RET_ECONTROLLER;
        }
        param[i++] = inb_r(PORT_FD_DATA);
    }

    return DISK_RET_SUCCESS;
}


int floppy_drive_readid_r(struct mybda_t *mybda, u8r floppyid, u8r data_rate_r, u8r head)
{
    // Set data rate.
    outb_r(data_rate_r, PORT_FD_DIR);

    // send Read Sector Id command
    u8r param[7];
    param[0] = (head << 2) | floppyid; // HD DR1 DR2
    int ret = floppy_drive_pio_r(mybda, floppyid, FC_READID, param);
    if (ret)
        return ret;
    if (param[0] & 0xc0)
        return -1;
    return 0;
}


// Setup the DMA controller for a floppy transfer.
int
dma_floppy_r(u32r addr, int count, int isWrite)
{
    // check for 64K boundary overrun
    u16r end = count - 1;
    u32r last_addr = addr + end;
    if ((addr >> 16) != (last_addr >> 16))
        return -1;

    u8r mode_register = 0x46; // single mode, increment, autoinit disable,
    if (isWrite)
        mode_register = 0x4a;

    outb_r(0x06, PORT_DMA1_MASK_REG);
    outb_r(0x00, PORT_DMA1_CLEAR_FF_REG); // clear flip-flop
    outb_r(addr, PORT_DMA_ADDR_2);
    outb_r(addr>>8, PORT_DMA_ADDR_2);
    outb_r(0x00, PORT_DMA1_CLEAR_FF_REG); // clear flip-flop
    outb_r(end, PORT_DMA_CNT_2);
    outb_r(end>>8, PORT_DMA_CNT_2);

    // port 0b: DMA-1 Mode Register
    // transfer type=write, channel 2
    outb_r(mode_register, PORT_DMA1_MODE_REG);

    // port 81: DMA-1 Page Register, channel 2
    outb_r(addr>>16, PORT_DMA_PAGE_2);

    outb_r(0x02, PORT_DMA1_MASK_REG); // unmask channel 2

    return 0;
}
